#!/bin/sh
""""exec ${PYTHON:-python} -t $0 "$@";" """

__author__ = "Jeff Fisher <guppy@techmonkeys.org>"
__copyright__ = "Copyright 2010 Jeff Fisher"
__license__ = "GPL v2"

import copy
import glob
import os
import os.path
import shutil
import sys
import ConfigParser

defaults = {
	"root": {"type": "string", "value": None, "default": True},
	"rsync_cmd": {"type": "string", "value": "rsync", "default": True},
	"rsync_args": {"type": "string", "value": "-qaHz --delete-during --numeric-ids", "default": True},
	"hourly": {"type": "integer", "value": 6, "default": True},
	"daily": {"type": "integer", "value": 7, "default": True},
	"weekly": {"type": "integer", "value": 4, "default": True},
}

# 0 = Success
# 24 = Partial transfer due to vanished source files
# 25 = The --max-delete limit stopped deletions
# Anything else is considered a failure and the backup will be deleted
rsync_allowed_exitcodes = (0, 24, 25)

def find_snapshot(location):
	recent_snapshot = None
	recent_unixtime = 0

	for interval in ('hourly', 'daily', 'weekly', 'monthly'):
		for snapshot in glob.glob(os.path.join(location, "%s.*" % interval)):
			mtime = os.path.getmtime(snapshot)
			if mtime > recent_unixtime:
				recent_unixtime = mtime
				recent_snapshot = snapshot

	return recent_snapshot
					
def rotate_snapshots(location, interval, numcopies):
	numcopies -= 1
	highest = os.path.join(location, "%s.%d" % (interval, numcopies))

	if os.path.exists(highest):
		shutil.rmtree(highest)

	for i in range(numcopies - 1, -1, -1): 
		src = os.path.join(location, "%s.%d" % (interval, i))
		dst = os.path.join(location, "%s.%d" % (interval, i + 1))

		if os.path.exists(src):
			shutil.move(src, dst)

	dst = os.path.join(location, "%s.0" % interval)
	shutil.move(os.path.join(location, ".%s.0" % interval), dst)
	os.utime(dst, None)

def take_backup(settings, source, destination, interval):

	root = settings["root"]["value"]
	rsync_args = [settings["rsync_args"]["value"],]

	destination = os.path.join(root, destination)

	if not os.path.exists(destination):
		try:
			os.makedirs(destination)
		except Exception, e:
			print >>sys.stderr, "Unable to create backup directory:", e
			return False

	if not os.path.isdir(destination):
		print >>sys.stderr, "cannot create directory %s: File exists" % destination
		return False

	last_snapshot = find_snapshot(destination)

	if last_snapshot is not None:
		rsync_args.append("--link-dest=%s" % last_snapshot)

	tmp_snapshot = os.path.join(destination, ".%s.0" % interval)

	if os.path.exists(tmp_snapshot):
		print >>sys.stderr, "cannot create backup %s: File exists" % tmp_snapshot
		return False

	ret = os.system("%s %s %s/. %s" % (settings["rsync_cmd"]["value"], " ".join(rsync_args), source, tmp_snapshot))

	if os.WIFEXITED(ret):
		exitcode = os.WEXITSTATUS(ret)
	else:
		exitcode = -1

	if not os.path.exists(tmp_snapshot):
		print >>sys.stderr, "cannot access %s: No such file or directory" % tmp_snapshot
		return False

	if exitcode in rsync_allowed_exitcodes:
		rotate_snapshots(destination, interval, settings[interval]["value"])
	else:
		print >>sys.stderr, "cannot finish backup %s: rsync executed with exit code %d" % (tmp_snapshot, exitcode)
	
		if os.path.exists(tmp_snapshot):
			shutil.rmtree(tmp_snapshot)

		return False

	return True

def process_config(configfile, interval):
	global defaults

	config = ConfigParser.SafeConfigParser()
	try:
		config.read(configfile)
	except Exception, e:
		print >>sys.stderr, e
		return False

	if config.has_section("default"):
		for setting, value in config.items("default"):
			if setting in defaults:
				tmp = defaults.get(setting)
				if tmp["type"] == "string":
					try:
						tmp["value"] = config.get("default", setting)
					except ValueError:
						print >>sys.stderr, "Unable to get the value for '%s' in the default section" % setting
						return False
				elif tmp["type"] == "boolean":
					try:
						tmp["value"] = config.getboolean("default", setting)
					except ValueError:
						print >>sys.stderr, "Unable to get a boolean value for '%s' in the default section" % setting
						return False
				elif tmp["type"] == "integer":
					try:
						tmp["value"] = config.getint("default", setting)
					except ValueError:
						print >>sys.stderr, "Unable to get an integer value for '%s' in the default section" % setting
						return False
	
				defaults[setting] = tmp
			else:
				return (False, "Unknown setting '%s'" % setting)

	for group in [i for i in config.sections() if i != "default"]:
		if config.has_option(group, "skip"):
			skips = [i.strip() for i in config.get(group, "skip").replace(" ", "").split(",")]
			if interval in skips:
				continue
	
		settings = copy.deepcopy(defaults)
		settings["source"] = {"type": "string", "value": None, "default": True}

		for setting in settings:
			if config.has_option(group, setting):
				tmp = settings.get(setting)
				if tmp["type"] == "string":
					try:
						tmp["value"] = config.get(group, setting)
					except ValueError:
						print >>sys.stderr, "Unable to get the value for '%s' in the '%s' group" % (setting, group)
						return False
				elif tmp["type"] == "boolean":
					try:
						tmp["value"] = config.getboolean(group, setting)
					except ValueError:
						print >>sys.stderr, "Unable to get a boolean value for '%s' in the '%s' group" % (setting, group)
						return False
				elif tmp["type"] == "integer":
					try:
						tmp["value"] = config.getint(group, setting)
					except ValueError:
						print >>sys.stderr, "Unable to get an integer value for '%s' in the '%s' group" % (setting, group)
						return False

				tmp["default"] = False
				settings[setting] = tmp

		root = settings["root"]

		if root["value"] is None:
			print >>sys.stderr, "The 'root' option in '%s' must be set" % group
			return False

		root["value"] = os.path.realpath(os.path.expanduser(root["value"]))

		if not os.path.isdir(root["value"]):
			print >>sys.stderr, "%s is not a directory" % root["value"]
			return False

		if config.has_option(group, "source"):
			source = config.get(group, "source")

			if root["default"]:
				root["value"] = os.path.join(root["value"], group)

				if not os.path.exists(root["value"]):
					try:
						os.makedirs(root["value"])
					except Exception, e:
						print >>sys.stderr, "Unable to create backup directory:", e
						return False
		else:
			source = None

		settings["root"] = root

		for setting, value in config.items(group):
			if setting in settings or setting == "skip":
				continue
	
			if source is not None:
				if setting == "backup":
					for i in value.split(","):
						i = i.strip()
						take_backup(settings, source + i, i, interval)
					continue
				else:
					value = source + value

			take_backup(settings, value, setting, interval)

	return True

if __name__ == "__main__":
	from optparse import OptionParser

	usage = "usage: %prog [options] hourly|daily|weekly"

	def print_usage():
		print >>sys.stderr, usage
		sys.exit(1)
		
	parser = OptionParser(usage=usage)
	parser.add_option("-c", "--config", action="store", dest="config", default=None, help="Backup configuration file or directory")

	(opts, args) = parser.parse_args()

	if len(args) != 1 or args[0] not in ("hourly", "daily", "weekly"):
		print_usage()

	if opts.config is None:
		for f, t in (('snappy.conf', 'file'), ('snappy.d', 'dir')):
			for x in ("", "~/.", "/etc/"):
				tmp = os.path.realpath(os.path.expanduser("%s%s" % (f, x)))
			
				if t == "file" and os.path.isfile(tmp):
					opts.config = (tmp,)
					break

				if t == "dir" and os.path.isdir(tmp):
					opts.config = glob.glob(os.path.join(tmp, "*.conf"))
					break

	if opts.config is None:
		print >>sys.stderr, "No configuration file or directory was found"
		sys.exit(1)

	for config in opts.config:
		process_config(config, args[0])

# vim: filetype=python noexpandtab	
